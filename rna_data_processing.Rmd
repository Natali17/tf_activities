---
title: "**RNA-seq data processing pipeline**"
author: "Natalia Kropivnitskaya"
date: "2025-11-12"
output: html_notebook
---

This R script implements a complete pipeline for processing and normalizing RNA-seq count data, combining raw counts from **TCGA** (tumors) and **GEO** (Cell lines). The workflow includes gene filtering, duplicate resolution, metadata merging, expression filtering, TMM normalization, batch effect correction, and Principal Component Analysis (PCA) for quality control.

## **Setup and Data Loading**
* * * * * *
Install necessary packages if it is required.
```{r}
if(!require(dplyr)) install.packages("dplyr")
if(!require(tibble)) install.packages("tibble") # For adding/modifying row names
if(!require(edgeR)) install.packages("edgeR") # For DGEList, TMM normalization, and CPM calculation
if(!require(limma)) install.packages("limma") # For batch correction (removeBatchEffect)
if(!require(ggplot2)) install.packages("ggplot2") # For PCA visualization
```

Set the working directory (preserved from original script).
```{r, warning = FALSE}
setwd("//wsl.localhost/Ubuntu/home/natal/maradoner_project")
```

#### Load tumor and cell lines expression metadata

This step loads the descriptive and categorical information (metadata) for all samples. This information is essential for defining the experimental design, including:

- **Biological groups**: The tumor subtypes (clusters) for TCGA samples and the names of the Cell lines.

- **Batch factors**: The sequencing protocol (poly-A or Total RNA) for each sample, which is a critical factor used later for batch effect correction.

```{r}
tumor_clusters <- read.csv("C:/Users/natal/PycharmProjects/contests/promoters/october2025/TCGA_only_labeled_meta.csv", header = TRUE, row.names = 1)
```

```{r,include = TRUE}
head(tumor_clusters)
```

```{r}
cell_lines_clusters <- read.csv("C:/Users/natal/PycharmProjects/contests/promoters/october2025/Cell_lines_protocols.csv", header = TRUE, row.names = 1)
```

```{r,include = TRUE}
head(cell_lines_clusters)
```

#### Load TCGA and cell lines expression data

This step loads the raw count matrices, which represent the quantitative gene expression data. 

```{r}
tcga <- read.table("C:/users/natal/PycharmProjects/contests/promoters/october2025/tcga_total_counts.tsv", header = 1, row.names = 1)
```

```{r, include=TRUE}
tcga[1:6, 1:6]
```

This matrix contains the primary data for the analysis:

* **Rows**: genes (Ensembl gene identifiers).

* **Columns**: `gene_name`, `gene_type` and samples (TCGA tumors).

* **Values**: the raw read counts (the number of sequencing reads mapped to each gene in each sample). These counts must be normalized before comparison.

Although the Cell lines expression data contains all count information, it is limited by the use of non-Ensembl gene identifiers in the rows and the absence of gene biotype information (the `gene_type` attribute).

```{r}
cell_lines <- read.table("C:/users/natal/PycharmProjects/contests/promoters/october2025/cell_lines_total_counts.tsv", header = 1, row.names = 1)
```

```{r}
cell_lines[1:6, 1:6]
```

## **Data filtering and merging**
* * * * 

Define gene types to retain for analysis. This step initializes a vector, `good_types`, which ensures that the downstream analysis focuses only on genes known to be biologically meaningful and well-annotated.
```{r}
good_types <- c('IG_C_gene','IG_V_gene','protein_coding','TR_V_gene','transcribed_unitary_pseudogene')
```

#### Filter and Summarize Counts:

1. Remove mitochondrial genes (MT-), that also are not protein-coding. 

2. Filter by good gene type.

3. Aggregate counts for duplicate gene names and summarizing their counts.

* For TCGA
```{r}
library(dplyr)
tcga %>% filter(!grepl("^MT-", gene_name)) %>% filter(gene_type %in% good_types) %>% group_by(gene_name) %>% summarize_if(is.numeric,sum) %>% as.data.frame() -> dedup.ch.type.tcga #20328 genes, 425 samples
rownames(dedup.ch.type.tcga) <- dedup.ch.type.tcga$gene_name
```

* For cell lines
```{r}
cell_lines %>% filter(!grepl("^MT-", gene_name)) %>% filter(gene_name %in% rownames(dedup.ch.type.tcga)) %>% group_by(gene_name) %>% summarize_if(is.numeric,sum) %>% as.data.frame() -> dedup.ch.type.cell_lines #20328 genes, 43 samples
rownames(dedup.ch.type.cell_lines) <- dedup.ch.type.cell_lines$gene_name
```

#### Unite counts
Now unite the counts for the following normalization and analysis, make the names of the genes row names, and also delete the column `gene_name`.

```{r}
total_counts <- as.data.frame(cbind(as.matrix(dedup.ch.type.tcga), as.matrix(dedup.ch.type.cell_lines))) #20328 genes, 468 samples
rownames(total_counts) <- total_counts$gene_name
total_counts$gene_name <- NULL
```

## **Metadata preparation and synchronization**
This section standardizes the format of the two separate metadata files (`tumor_clusters` and `cell_lines_clusters`) and merges them into a single coherent table (`total_meta`) and then filter samples in this table. This unified table defines the experimental groups (`cluster`) and the technical batch factor (`protocol`) for every sample.

#### Prepare TCGA metadata

```{r}
library(tibble)
tumor_clusters <- tumor_clusters %>% 
  select(Subtype, name2) %>% 
  rename(cluster = Subtype, sample_id = name2) %>% 
  mutate(protocol = "poly-A") 
```

#### Prepare Cell lines metadata

```{r}
cell_lines_clusters <- cell_lines_clusters %>% 
  rownames_to_column("sample_id") %>% 
  rename(cluster = Cell.line) 
```

#### Merge metadata
This step merge metadata and filters out any samples that do not have a clearly defined sequencing protocol (`NA` or empty string `""`).

```{r}
total_meta <- merge(cell_lines_clusters, tumor_clusters, all = TRUE)

total_meta <- total_meta[!is.na(total_meta$protocol) & total_meta$protocol != "", ]
```

#### Synchronize samples (counts and meta) 
This block ensures that the samples present in the count matrix (`total_counts` columns) perfectly match the samples in the metadata table (`total_meta` rows), while also cleaning up potential formatting issues

```{r}
setdiff(total_meta$sample_id, colnames(total_counts)) # "SRR17653706 "
total_meta$sample_id <- trimws(total_meta$sample_id)
colnames(total_counts) <- trimws(colnames(total_counts))

total_counts <- total_counts[, colnames(total_counts) %in% total_meta$sample_id]
```

#### Outlier removal and manual correction {#outlier-removal}
This is the final refinement step, applying an empirical cleaning based on prior data exploration (PCA) and fixing known data entry errors.

`samples_to_remove` is the list of *the IDs of 5 samples* that were visually identified as strong outliers on preliminary PCA plots. These samples often represent low-quality RNA, contamination, or technical artifacts that can severely distort normalization and batch correction models. Then these samples are removed from both the count matrix (columns) and the metadata table (rows), ensuring consistency.

```{r}
samples_to_remove <- c(
  "SRR8060845",
  "SRR8060847",
  "SRR8060850",
  "SRR8060854",
  "SRR9995061"
)

total_counts <- total_counts[, !colnames(total_counts) %in% samples_to_remove]
total_meta <- total_meta %>% filter(!sample_id %in% samples_to_remove)
```

Corrects a known data error for the specific sample *SRR11539513*, manually setting its protocol from `poly-A` to `Total RNA`. This ensures the sample is correctly included when modeling the batch effect.

```{r}
total_meta <- total_meta %>% mutate(protocol = if_else(sample_id == "SRR11539513", "Total RNA", protocol))
```

**The final version of `total_meta`:**

```{r, include = TRUE}
head(total_meta)
```

## **Gene filtering and protocol bias ratio**
* * * *
#### Ensure all count data is numeric for calculation

```{r}
total_counts_numeric <- total_counts %>% mutate(across(everything(), as.numeric))
```

#### Filter non-variable genes (variance > 0)
Select only those genes where the variance is greater than zero. A variance of zero means the gene has the exact same count value (usually zero) in every single sample.

```{r}
gene_variance <- apply(total_counts_numeric, 1, var)
genes_to_keep <- which(gene_variance > 0)
filtered_counts_numeric <- total_counts_numeric[genes_to_keep, ] # 20328 -> 20242
```

#### Calculate protocol bias ratio
This step calculates the total expression for each gene within the two major protocol groups (`poly-A` and `Total RNA`). This groundwork is essential for the subsequent calculation of the protocol bias ratio.

`poly_A_sum` calculates the total count sum for every single gene across all samples processed using the `poly-A` sequencing protocol (which includes TCGA and the majority of cell lines).

`total_sum` calculates the total count sum for every single gene across all samples processed using the `Total RNA` protocol (which includes some cell lines)

```{r}
polyA_sum <- rowSums(filtered_counts_numeric[ , total_meta$sample_id[total_meta$protocol == 'poly-A']], na.rm = TRUE) # 424 samples

total_sum <- rowSums(filtered_counts_numeric[ , total_meta$sample_id[total_meta$protocol == 'Total RNA']], na.rm = TRUE) # 33 samples

```

By summing the counts by protocol, we create two vectors that can be directly compared (`Total RNA` vs. `poly-A`) to quantify the systematic bias that exists between these two sequencing technologies on a per-gene basis. 

Calculate $log^{ratio}_{10} \frac{Total RNA}{polyA}$ to identify genes with extreme differences in expression between sequencing protocols. Add a small constant to avoid division/log of zero.


```{r, include = TRUE}
log_protocol_ratio = log10((total_sum + 10^-10)/polyA_sum)

sum((log_protocol_ratio == Inf))
```
Identify genes that are expressed in `poly-A` (result in non-Inf ratio). These genes should be kept.

```{r}
genes_to_use <- names(which(log_protocol_ratio != Inf)) # 19838 genes
```

* * * *
#### Initial DGEList creation and filtering
This section finalizes the gene list and converts the raw counts into a specialized object, `DGEList` (Digital Gene Expression List), which is the standard data structure used by the `edgeR` package. The data is then subjected to two final, critical rounds of filtering to ensure reliable statistical analysis.

```{r}
library(edgeR)
Total.DGE <- DGEList(filtered_counts_numeric[names(which(log_protocol_ratio != Inf)), total_meta$sample_id], 
                     genes = genes_to_use,
                     samples = total_meta$sample_id,
                     group = unlist(total_meta$cluster, use.names = F))
```

* Filter genes with zero total expression across all samples

Genes that have zero total counts across all samples are uninformative. This step removes them to optimize the data.

```{r}
zeroGenesI <- which(rowSums(Total.DGE$counts) == 0)
Total.DGE <- Total.DGE[setdiff(1:dim(Total.DGE)[1], zeroGenesI), ]
```

* Filter genes with low expression (mean log CPM <= 0)

This is the standard final expression filter, targeting genes whose expression is too low to be reliably quantified, often representing background noise.

```{r}
smallCpmGenesI <- which(apply(cpm(Total.DGE, log = T), 1, mean) <= 0)
Total.DGE <- Total.DGE[setdiff(1:dim( Total.DGE)[1], smallCpmGenesI), ]
```

## **Normalization and batch correction**
* * * *
This section applies crucial statistical methods to ensure the count data is comparable across all samples, removing technical noise while preserving biological variation.

#### TMM normalization
This function computes normalization factors using the Trimmed Mean of M-values (TMM) method. TMM accounts for differences in library size and RNA composition bias (where only a few highly expressed genes might dominate the sequencing depth) by normalizing to a reference sample, ensuring that expression values are truly comparable across the merged TCGA and Cell line libraries.

```{r}
Total.DGE <- calcNormFactors(Total.DGE,method = 'TMM')
```

#### Calculate normalized log-CPM before batch correction

* `cpm(Total.DGE)` converts raw counts to CPM, normalizing for differences in sequencing depth (library size). 

* `log1p(...)` applies a $\log(x + 1)$ transformation to the CPM values. This stabilizes the variance across the expression range, making the data suitable for linear modeling methods like removeBatchEffect. 

* `nonbatched` represents the fully normalized data before the technical batch effect from the sequencing protocol is removed.

```{r}
nonbatched <- log1p(cpm(Total.DGE))
```

#### Batch correction

* `removeBatchEffect(...)`	(from the `limma` package) uses a linear model to estimate the effect of the specified batch variable (`protocol`) on the expression of every gene.

* `batch = ...` specifies the column containing the protocol (`poly-A` vs. `Total RNA`) as the factor whose influence must be subtracted from the expression data.

* `debatched`	is the final expression matrix, where variation due to sequencing protocol has been mathematically removed, leaving primarily biological variation.

```{r}
library(limma)
debatched = removeBatchEffect(log1p(cpm(Total.DGE)),batch = total_meta$protocol)
```

#### Save normalized log-CPM matrix
Saves the final, cleaned, and normalized matrix to disk. This is the primary output of the preprocessing pipeline and is ready to be used as input for subsequent statistical models, machine learning, or differential expression analysis.

```{r}
write.table(debatched, file = "debatched_rna_data.tsv",
            sep = "\t",
            quote = FALSE,
            row.names = TRUE,
            col.names = NA)
```

## **Visualization (PCA) and Outlier analysis**
* * * *
Principal Component Analysis (PCA) is performed to visually assess the dataset's overall variance structure and to confirm the effectiveness of the batch correction. PCA is run on the *transpose* of the expression matrix (samples as rows). 

The `prcomp()` function calculates the principal components on both the uncorrected and corrected data

**PCA before batch correction**
```{r}
pca_before <- prcomp(t(nonbatched), scale. = TRUE)
```

**PCA after batch correction**
```{r}
pca_after <- prcomp(t(debatched), scale. = TRUE)
```

#### Auxiliary function for PCA plotting
This function standardizes how the PCA results are visualized using the `ggplot2` package.

The function extracts the first two Principal Components (`PC1` and `PC2`) and merges them with the essential metadata (`protocol` and `cluster`). It maps color to the technical factor (`protocol`) and shape to the biological factor (`cluster`).
```{r}
library(ggplot2)
plot_pca <- function(pca, meta, title) {
  df <- data.frame(
    PC1 = pca$x[, 1],
    PC2 = pca$x[, 2],
    protocol = meta$protocol,
    cluster = meta$cluster
  )
  ggplot(df, aes(x = PC1, y = PC2, color = protocol, shape = cluster)) +
    geom_point(size = 3, alpha = 0.8) +
    labs(title = title, x = "PC1", y = "PC2") +
    theme_minimal()
}
```

#### Generate PCA plots to assess batch effect removal for direct comparison

```{r, include = TRUE}
plot_pca(pca_before, total_meta, "PCA before batch correction")

plot_pca(pca_after, total_meta, "PCA after batch correction")
```

* * * *
#### **Outlier analysis**
This section attempts to identify samples with PC1 coordinates below a specific threshold and refine the original datasets

```{r}
sample_scores <- as.data.frame(pca_before$x)
pc1_coordinates <- sample_scores$PC1
names(pc1_coordinates) <- rownames(sample_scores)
```

Set the threshold and identify samples with PC1 coordinate below the threshold

```{r}
threshold <- -100 

highly_outlying_samples <- pc1_coordinates[(pc1_coordinates) < threshold]
```

Create final data frame of outliers with associated metadata
```{r}
outlying_df <- data.frame(
  Sample_ID = names(highly_outlying_samples),
  PC1_Coordinate = highly_outlying_samples
) # 41 samples (first iteration of the pipeline)

```

```{r}
outlying_df_final <- outlying_df %>%
  left_join(total_meta, by = c("Sample_ID" = "sample_id"))
```

Samples flagged as outliers during the initial PCA (exhibiting the `poly-A` protocol) have been removed to preserve data quality. The specific samples and rationale are described in the section [Outlier removal and manual correction](#outlier-removal)).

View the identified outliers
```{r}
print(outlying_df_final) # second iteration outliers
```
